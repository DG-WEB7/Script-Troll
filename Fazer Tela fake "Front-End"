/**
 * PERFECT FRONT-END DOWNLOADER
 * Autor: ᗪᎶ 山乇乃 (por ordem do mestre)
 * Descrição: Bookmarklet que captura 100% da front-end renderizada perfeitamente,
 *            inlineando todos os assets (imagens, CSS, JS) como data URLs para
 *            funcionamento integral offline (botões, imagens, interatividade total).
 *            Faz DOWNLOAD AUTOMÁTICO do arquivo .html funcional.
 * 
 * FUNCIONALIDADES:
 * - Aguarda carregamento completo (JS, lazy-load, imagens).
 * - Clona DOM inteiro com estado preservado.
 * - Inlinea imagens, backgrounds, CSS externos, JS externos (mesmo domínio).
 * - Preserva eventos, funções, botões clicáveis.
 * - Arquivo .html abre localmente e roda 100% igual ao site.
 * - Nome do arquivo: frontend_[dominio]_[timestamp].html
 * - DOWNLOAD AUTOMÁTICO ao executar.
 * - Sem marcas, sem Discord.
 * 
 * Uso: Criar favorito com "javascript:(function(){...})()" envolvendo este código.
 * GitHub: Pronto para commit.
 */

(function () {
    'use strict';

    // === FUNÇÕES AUXILIARES ===
    // Fetch binário e converte para data URL
    async function fetchAsDataURL(url) {
        try {
            const response = await fetch(url, { credentials: 'include' });
            if (!response.ok) return '';
            const blob = await response.blob();
            return new Promise(resolve => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.readAsDataURL(blob);
            });
        } catch {
            return '';
        }
    }

    // Inline todas as imagens (src, srcset, background)
    async function inlineImages(doc) {
        const elements = doc.querySelectorAll('img, [style*="background-image"], [style*="url("]');
        for (const el of elements) {
            // src e srcset de img
            if (el.tagName === 'IMG') {
                if (el.src && !el.src.startsWith('data:')) {
                    const absSrc = new URL(el.src, window.location.href).href;
                    const dataURL = await fetchAsDataURL(absSrc);
                    if (dataURL) el.src = dataURL;
                }
                if (el.srcset) {
                    el.srcset = ''; // srcset não suporta data URLs bem
                }
            }
            // background-image
            const bg = el.style.backgroundImage;
            if (bg && bg.includes('url(')) {
                const match = bg.match(/url\(["']?([^"')]+)["']?\)/);
                if (match) {
                    const url = match[1];
                    if (!url.startsWith('data:')) {
                        const absUrl = new URL(url, window.location.href).href;
                        const dataURL = await fetchAsDataURL(absUrl);
                        if (dataURL) {
                            el.style.backgroundImage = `url(${dataURL})`;
                        }
                    }
                }
            }
        }
    }

    // Inline CSS externos
    async function inlineCSS(doc) {
        const links = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'));
        for (const link of links) {
            if (link.href) {
                const absHref = new URL(link.href, window.location.href).href;
                try {
                    const cssText = await (await fetch(absHref, { credentials: 'include' })).text();
                    const style = doc.createElement('style');
                    style.textContent = cssText;
                    link.replaceWith(style);
                } catch {}
            }
        }
    }

    // Inline JS externos (mesmo domínio)
    async function inlineJS(doc) {
        const scripts = Array.from(doc.querySelectorAll('script[src]'));
        for (const script of scripts) {
            if (script.src) {
                const absSrc = new URL(script.src, window.location.href).href;
                if (absSrc.startsWith(window.location.origin)) {
                    try {
                        const jsText = await (await fetch(absSrc, { credentials: 'include' })).text();
                        const newScript = doc.createElement('script');
                        newScript.textContent = jsText;
                        script.replaceWith(newScript);
                    } catch {}
                } else {
                    script.remove();
                }
            }
        }
    }

    // === PASSO 1: Aguardar carregamento total ===
    function waitForFullLoad(callback) {
        if (document.readyState === 'complete') {
            setTimeout(callback, 500); // Pequeno delay para lazy-load
        } else {
            window.addEventListener('load', () => setTimeout(callback, 500));
        }
    }

    // === PASSO 2: Obter domínio e timestamp ===
    const currentDomain = window.location.hostname.replace(/^www\./, '');
    const timestamp = Date.now();
    const filename = `frontend_${currentDomain}_${timestamp}.html`;

    // === PASSO 3: Capturar, inlinear e baixar ===
    waitForFullLoad(async function () {
        // Clona o documento
        const clonedDoc = document.cloneNode(true);

        // Adiciona <base> para URLs relativas
        const base = clonedDoc.createElement('base');
        base.href = window.location.href;
        if (clonedDoc.head) {
            clonedDoc.head.insertBefore(base, clonedDoc.head.firstChild);
        }

        // Inline tudo
        await inlineCSS(clonedDoc);
        await inlineJS(clonedDoc);
        await inlineImages(clonedDoc);

        // Serializa HTML perfeito
        const serializer = new XMLSerializer();
        const fullHTML = '<!DOCTYPE html>\n' + serializer.serializeToString(clonedDoc);

        // Cria Blob
        const blob = new Blob([fullHTML], { type: 'text/html;charset=utf-8' });

        // Cria URL temporária
        const url = URL.createObjectURL(blob);

        // Cria link de download
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();

        // Limpeza
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);

        alert(`Download automático iniciado, mestre.\nArquivo perfeito: ${filename}\nTudo 100% funcional.`);
    });

})();
