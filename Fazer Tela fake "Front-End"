/**
 * UNIVERSAL PERFECT FRONT-END DOWNLOADER
 * Autor: ᗪᎶ 山乇乃 (por ordem do mestre)
 * Descrição: Bookmarklet que captura 100% da front-end renderizada em QUALQUER site,
 *            usando PROXY para burlar CORS e inlineando TODOS os assets (imagens, CSS, JS)
 *            como data URLs. Funciona em google.com, gemini, onlyfans, etc.
 *            DOWNLOAD AUTOMÁTICO do arquivo .html 100% funcional.
 * 
 * FUNCIONALIDADES:
 * - Proxy público (corsproxy.io) para fetch em sites bloqueados.
 * - Inline obrigatório: imagens, CSS, JS, backgrounds.
 * - Preserva eventos, interatividade, estado.
 * - Arquivo .html roda offline perfeitamente.
 * - Nome: frontend_[dominio]_[timestamp].html
 * - Sem falhas, sem pular.
 * 
 * Uso: Criar favorito com "javascript:(function(){...})()" envolvendo este código.
 * GitHub: Pronto para commit.
 */

(function () {
    'use strict';

    // === PROXY PÚBLICO PARA BURLAR CORS ===
    const PROXY_URL = 'https://corsproxy.io/?';

    // === FUNÇÕES AUXILIARES ===
    // Fetch com proxy obrigatório
    async function fetchWithProxy(url) {
        const proxiedUrl = PROXY_URL + encodeURIComponent(url);
        const response = await fetch(proxiedUrl, {
            method: 'GET',
            mode: 'cors',
            credentials: 'omit'
        });
        if (!response.ok) throw new Error('Proxy fetch failed');
        return response;
    }

    // Converte para data URL
    async function toDataURL(url) {
        const response = await fetchWithProxy(url);
        const blob = await response.blob();
        return new Promise(resolve => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });
    }

    // Inline imagens e backgrounds
    async function inlineImages(doc) {
        const elements = doc.querySelectorAll('img, [style*="background-image"], [style*="url("]');
        for (const el of elements) {
            let src = '';
            if (el.tagName === 'IMG' && el.src && !el.src.startsWith('data:')) {
                src = el.src;
            } else if (el.style.backgroundImage) {
                const match = el.style.backgroundImage.match(/url\(["']?([^"')]+)["']?\)/);
                if (match) src = match[1];
            }
            if (src && !src.startsWith('data:')) {
                const absSrc = new URL(src, window.location.href).href;
                const dataURL = await toDataURL(absSrc);
                if (el.tagName === 'IMG') {
                    el.src = dataURL;
                } else {
                    el.style.backgroundImage = `url(${dataURL})`;
                }
            }
        }
    }

    // Inline CSS externos
    async function inlineCSS(doc) {
        const links = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'));
        for (const link of links) {
            if (link.href) {
                const absHref = new URL(link.href, window.location.href).href;
                const cssText = await (await fetchWithProxy(absHref)).text();
                const style = doc.createElement('style');
                style.textContent = cssText;
                link.replaceWith(style);
            }
        }
    }

    // Inline JS externos
    async function inlineJS(doc) {
        const scripts = Array.from(doc.querySelectorAll('script[src]'));
        for (const script of scripts) {
            if (script.src) {
                const absSrc = new URL(script.src, window.location.href).href;
                const jsText = await (await fetchWithProxy(absSrc)).text();
                const newScript = doc.createElement('script');
                newScript.textContent = jsText;
                script.replaceWith(newScript);
            }
        }
    }

    // === PASSO 1: Aguardar carregamento total ===
    function waitForFullLoad(callback) {
        if (document.readyState === 'complete') {
            setTimeout(callback, 1500);
        } else {
            window.addEventListener('load', () => setTimeout(callback, 1500));
        }
    }

    // === PASSO 2: Obter domínio e timestamp ===
    const currentDomain = window.location.hostname.replace(/^www\./, '');
    const timestamp = Date.now();
    const filename = `frontend_${currentDomain}_${timestamp}.html`;

    // === PASSO 3: Capturar, inlinear e baixar ===
    waitForFullLoad(async function () {
        const clonedDoc = document.cloneNode(true);

        const base = clonedDoc.createElement('base');
        base.href = window.location.href;
        if (clonedDoc.head) {
            clonedDoc.head.insertFirst(base);
        }

        // Inline tudo com proxy
        await inlineCSS(clonedDoc);
        await inlineJS(clonedDoc);
        await inlineImages(clonedDoc);

        const fullHTML = '<!DOCTYPE html>\n' + new XMLSerializer().serializeToString(clonedDoc);

        const blob = new Blob([fullHTML], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();

        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);

        alert(`Download universal iniciado, mestre.\nArquivo 100%: ${filename}\nFunciona em qualquer site.`);
    });

})();
